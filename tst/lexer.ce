{ #include <string.h> }
{ #include <ctype.h> }
{ typedef struct { char v[256]; } Tk_s }

data Tk:        -- TODO: inheritance // optional | \n
    Tk_ERR
    Tk_EOF
    Tk_LINE     {int}
    Tk_COMMENT
    Tk_ARROW
    Tk_IDVAR    {Tk_s}
    Tk_IDDATA   {Tk_s}

mut inp :: {FILE*}

func lexer_ :: (() -> Tk):
    match {fgetc} (inp):
        {EOF}  -> Tk_EOF
        {'\n'} -> let i :: {int} = {0}:         -- TODO: loop i
            loop:
                match {fgetc} (inp):
                    {EOF} -> return Tk_EOF      -- consider \nEOF as EOF
                    {' '} -> set i = {i+1}
                    c :: {int}:
                        {ungetc} (c,inp)
                        break
            if:
                {i%4 == 0} -> return Tk_LINE ({i/4})
                else       -> return Tk_ERR
        {'-'}:
            match {fgetc} (inp):
                {'>'} -> return Tk_ARROW
                {'-'} -> :
                    loop:
                        match {fgetc} (inp):
                            {EOF}:
                                {ungetc} ({EOF},inp)
                                return Tk_COMMENT
                            {'\n'}:                     -- TODO `;` for seq
                                {ungetc} ({'\n'},inp)
                                return Tk_COMMENT
                            else -> pass
                else  -> return Tk_ERR
        c :: {int} -> let (i,ret) :: ({int},{Tk_s}) = ({0},{(Tk_s){""}}):
            if:
                {isalpha (c)} -> pass
                else          -> return Tk_ERR   -- TODO: optional else
            loop:
                if:
                    {isalnum(c) || c=='_' || c=='\'' || c=='?' || c=='!'} -> pass
                    else -> break  -- TODO: optional else
                set {ret.v[i]} = c
                set i = {i+1}
                set c = {fgetc} (inp)
            set {ret.v[i]} = {'\0'}
            {ungetc} (c,inp)
            return if {islower (ret.v[0])} -> Tk_IDVAR (ret) -> Tk_IDDATA (ret)

func lexer :: (() -> Tk):
    let tk :: Tk = lexer_():
        loop:
            match {fgetc} (inp):
                {' '} -> pass
                c :: {int}:
                    {ungetc} (c,inp)
                    break
        return tk

func stropen :: (({char*}, {size_t}, {char*}) -> {FILE*}): -- TODO: (mode::char*, ...)
    let (mode,size,str) :: ({char*}, {size_t}, {char*}) = ...:
        set size = match size:
            {0}  -> {strlen} (str)
            else -> size
        { fmemopen (str,size,mode) }

func t_lexer :: (() -> ()):
    :
        set inp = stropen ({"r"}, {0}, {"-- foobar"})
        {assert} (lexer() ~ Tk_COMMENT)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"-- c1\n--c2\n\n"})
        {assert} (lexer() ~ Tk_COMMENT)
        {assert} (lexer() ~ Tk_LINE)
        {assert} (lexer() ~ Tk_COMMENT)
        {assert} (lexer() ~ Tk_LINE)
        {assert} (lexer() ~ Tk_EOF)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"\n  \n"})
        {assert} (lexer() ~ Tk_ERR)
        {assert} (lexer() ~ Tk_EOF)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"c1\nc2 c3'  \n    \nc4"})
        match lexer():
            Tk_IDVAR (s) :: {Tk_s} -> {assert (! strcmp (s.v,"c1"))}
        {assert} (lexer() ~ Tk_LINE)
        match lexer():
            Tk_IDVAR (s) :: {Tk_s} -> {assert (! strcmp (s.v,"c2"))}
        match lexer():
            Tk_IDVAR (s) :: {Tk_s} -> {assert (! strcmp (s.v,"c3'"))}
        {fclose} (inp)

t_lexer ()

{ puts("OK") }
