{ #include <string.h> }
{ typedef char Tk_s[256] }

data Tk:        -- TODO: inheritance // optional | \n
    Tk_ERR
    Tk_EOF
    Tk_LINE {int}
    Tk_COMMENT
    Tk_ARROW

mut inp :: {FILE*}

func lexer :: (() -> Tk):
    case {fgetc} (inp):
        {EOF}  -> Tk_EOF
        {'\n'} -> let i :: {int} = {0}:
            loop:
                case {fgetc} (inp):
                    {EOF} -> return Tk_EOF      -- consider \nEOF as EOF
                    {' '} -> set i = {i+1}
                    c :: {int}:
                        call {ungetc} (c,inp)
                        break
            if:
                {i%4 == 0} -> return Tk_LINE ({i/4})
                else       -> return Tk_ERR
        {'-'}:
            case {fgetc} (inp):
                {'>'} -> return Tk_ARROW
                {'-'} -> :
                    {puts("1")}
                    loop:
                        case {fgetc} (inp):
                            {EOF}:
                                call {ungetc} ({EOF},inp)
                                return Tk_COMMENT
                            {'\n'}:                     -- TODO `;` for seq
                                call {ungetc} ({'\n'},inp)
                                return Tk_COMMENT
                            else -> pass
                else  -> return Tk_ERR
        c :: {int}:
            { printf(">>> %d %c\n", c, c) }
            return Tk_ERR

func stropen :: (({char*}, {size_t}, {char*}) -> {FILE*}): -- TODO: (mode::char*, ...)
    let (mode,size,str) :: ({char*}, {size_t}, {char*}) = ...:
        set size = case size:
            {0}  -> {strlen} (str)
            else -> size
        { fmemopen (str,size,mode) }

func t_lexer :: (() -> ()):
    :
        set inp = stropen ({"r"}, {0}, {"-- foobar"})
        let tk :: Tk = lexer():             -- TODO: it // optional [tk :: Tk =] (assume it)
            call {show_Tk}(tk)
            call {assert} (tk ~ Tk_COMMENT (_))

call t_lexer ()

{ puts("OK") }
