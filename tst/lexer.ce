{ #include <string.h> }
{ #include <ctype.h> }
{ typedef struct { char v[256]; } String }

data Bool:
    False
    True

func to_bool :: ({int} -> Bool):
    match ...:
        {0}  -> False
        else -> True

data Tk:        -- TODO: inheritance // optional | \n
    Tk_ERR
    Tk_CHAR     {char}
    Tk_EOF
    Tk_LINE     {int}
    Tk_COMMENT
    Tk_DECL
    Tk_ARROW
    Tk_IDVAR    {String}
    Tk_IDDATA   {String}
    Tk_LET

data Keywords
data Keywords:
    Key_NIL
    Key_CNS ({String},Tk,Keywords)

data Maybe_Key:
    Key_Nothing
    Key_Just Tk

val keys :: Keywords = new Key_CNS ({(String){"let"}},Tk_LET,new Key_NIL)
mut out :: {FILE*}
mut inp :: {FILE*}

func reserved_ :: ((Keywords,{String}) -> Maybe_Key):
    val (keys,key) :: (Keywords,{String}) = ...
    match keys:
        Key_NIL -> Key_Nothing
        Key_CNS (str,tk,l) :: ({String},Tk,Keywords):
            if:
                {!strcmp(key.v,str.v)} -> Key_Just(tk)
                else -> reserved_ (l,key)

func lexer_ :: (() -> Tk):
    match {fgetc} (inp):
        {EOF}  -> Tk_EOF
        {'\n'} -> :
            val i :: {int} = {0}
            loop:                               -- TODO: loop i
                match {fgetc} (inp):
                    {EOF} -> return (Tk_EOF)      -- consider \nEOF as EOF
                    {' '} -> set i = {i+1}
                    c :: {int}:
                        {ungetc} (c,inp)
                        break
            if:
                {i%4 == 0} -> return (Tk_LINE ({i/4}))
                else       -> return (Tk_ERR)
        {'-'}:
            match {fgetc} (inp):
                {'>'} -> return (Tk_ARROW)
                {'-'} -> :
                    loop:
                        match {fgetc} (inp):
                            {EOF}:
                                {ungetc} ({EOF},inp)
                                return (Tk_COMMENT)
                            {'\n'}:                     -- TODO `;` for seq
                                {ungetc} ({'\n'},inp)
                                return (Tk_COMMENT)
                            else -> pass
                else  -> return (Tk_ERR)
        {':'}:
            match {fgetc} (inp):
                {':'} -> return (Tk_DECL)
                c :: {int}:
                    {ungetc} (c,inp)
                    return (Tk_CHAR ({':'}))
        c :: {int}:
            mut i   :: {int}    = {0}
            mut ret :: {String} = {(String){""}}
            return (Tk_ERR) if {!isalpha (c)}
            loop:
                break if {!(isalnum(c) || c=='_' || c=='\'' || c=='?' || c=='!')}
                {ret.v[i] = c}
                set i = {i+1}
                set c = {fgetc} (inp)
            {ret.v[i] = '\0'}
            {ungetc} (c,inp)
            match reserved_(keys,ret):
                Key_Nothing:
                    if {islower (ret.v[0])} -> Tk_IDVAR (ret) -> Tk_IDDATA (ret)
                Key_Just(tk) :: Tk -> tk

func lexer :: (() -> Tk):
    val tk :: Tk = lexer_()
    loop:
        match {fgetc} (inp):
            {' '} -> pass
            c :: {int}:
                {ungetc} (c,inp)
                break
    return (tk)

func stropen :: (({char*}, {size_t}, {char*}) -> {FILE*}): -- TODO: (mode::char*, ...)
    val (mode,size,str) :: ({char*}, {size_t}, {char*}) = ...
    set size = match size:
        {0}  -> {strlen} (str)
        else -> size
    { fmemopen (str,size,mode) }

func init :: (({FILE*},{FILE*}) -> ()):
    set (out,inp) = ...
    --if {inp != NULL} -> pr_init() -> pass

func t_lexer :: (() -> ()):
    :
        set inp = stropen ({"r"}, {0}, {"-- foobar"})
        {assert} (lexer() ~ Tk_COMMENT)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"-- c1\n--c2\n\n"})
        {assert} (lexer() ~ Tk_COMMENT)
        {assert} (lexer() ~ Tk_LINE)
        {assert} (lexer() ~ Tk_COMMENT)
        {assert} (lexer() ~ Tk_LINE)
        {assert} (lexer() ~ Tk_EOF)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"\n  \n"})
        {assert} (lexer() ~ Tk_ERR)
        {assert} (lexer() ~ Tk_EOF)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"c1\nc2 c3'  \n    \nc4"})
        -- TODO: assert ... where
        match lexer():
            Tk_IDVAR (s) :: {String} -> {assert (! strcmp (s.v,"c1"))}
        {assert} (lexer() ~ Tk_LINE)
        match lexer():
            Tk_IDVAR (s) :: {String} -> {assert (! strcmp (s.v,"c2"))}
        match lexer():
            Tk_IDVAR (s) :: {String} -> {assert (! strcmp (s.v,"c3'"))}
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"c1 C1 C'a a'? C!!"})
        match lexer():
            Tk_IDVAR  (s) :: {String} -> {assert (! strcmp (s.v,"c1"))}
        match lexer():
            Tk_IDDATA (s) :: {String} -> {assert (! strcmp (s.v,"C1"))}
        match lexer():
            Tk_IDDATA (s) :: {String} -> {assert (! strcmp (s.v,"C'a"))}
        match lexer():
            Tk_IDVAR  (s) :: {String} -> {assert (! strcmp (s.v,"a'?"))}
        match lexer():
            Tk_IDDATA (s) :: {String} -> {assert (! strcmp (s.v,"C!!"))}
        {assert} (lexer() ~ Tk_EOF)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {"let xlet letx"})
        {assert} (lexer() ~ Tk_LET)
        match lexer():
            Tk_IDVAR (s) :: {String} -> {assert (! strcmp (s.v,"xlet"))}
        match lexer():
            Tk_IDVAR (s) :: {String} -> {assert (! strcmp (s.v,"letx"))}
        {assert} (lexer() ~ Tk_EOF)
        {fclose} (inp)
    :
        set inp = stropen({"r"}, {0}, {": :: :"})
        let tk :: Tk = lexer():
            {assert} (tk ~ Tk_CHAR({':'}))
        {assert} (lexer() ~ Tk_DECL)
        let tk :: Tk = lexer():
            {assert} (tk ~ Tk_CHAR({':'}))
        {fclose} (inp)

func t_type :: (() -> ()):
    init ({NULL}, stropen({"r"}, {0}, {"()"}))
    --{assert} (parser_type() ~ TYPE_UNIT)
    {fclose} (inp)

:
    t_lexer ()
    t_type  ()

{ puts("OK") }
